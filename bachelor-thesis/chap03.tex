\chapter{{HTN} Semantics}

\medskip\noindent
So far we have only discussed the definitions of classical and hierarchical planning. In this chapter, we will consider various semantics for hierarchical planning. A large part of this chapter will compare and describe semantics concerning \emph{empty methods} which are not defined properly within Definition~\ref{def02:10}. The main issue regarding \emph{empty methods} is caused by the unclear and ambiguous modification of \emph{task network's} constraints. It is uncertain how and when the modified constraints need to be checked. In the first part of this chapter, we will analyze existing approaches and propose new ways of handling \emph{empty methods} concerning the HTN plan verification process. In the second part, we will introduce a new idea for modeling hierarchical planning problems without the negative effects of \emph{primitive tasks}.

\section{Empty Methods}

\medskip\noindent
The following section will describe different solutions of how to handle \emph{empty methods}.

\begin{example}\label{ex03:5}
    Suppose we have a basic \emph{task network} $\omega = (\{t1, t2\}, \{t1 \prec t2, \\ before(p, t2)\})$. In natural language, we would say that task (\emph{primitive} or \emph{compound}) $t1$ must precede task $t2$, and at the same time, before executing the first task to which task $t2$ decomposes (in case of a \emph{primitive task}, we mean the state before the \emph{application} of the task $t2$) the \emph{propositional symbol} $p$ must hold in a state. Having an \emph{empty method} $m$ such that:
    
    \[
        t2 \rightarrow \varepsilon \quad [C], \; where \; C = \emptyset \; and \; \varepsilon \; denotes \; no \; subtasks,
    \]
    
    \noindent
    we can decompose the $t2$ in \emph{task network} $\omega$. After the $application$ of the \emph{empty method} $m$, we are not able to tell with certainty the result \emph{task network}. By \emph{applying} $m$, we erase the task $t2$ from the set of tasks in $\omega$ and we modify all of the constraints in $C$. The unclear result might look like this: $\omega' = (\{t1\}, \{t1 \prec \; ?, \\ before(p, ?)\})$ with $?$ symbolizing undefined behaviour. Thus, the following section will study different ways of representing HTN planning with the goal of resolving undefined behavior of \emph{empty methods}. Usually, we will need some additional information about \emph{task network's} decomposition process which will deal with unclear situations. Sometimes we will need to modify existing definitions from previous chapters.
\end{example}

\subsection{No Empty Methods Model}\label{sub03:311}

\medskip\noindent
The most effortless way to handle \emph{empty methods} is to forbid them (every dictator would approve). This way, each \emph{method} $m \in M$ must have nonempty set of $subtasks(m)$, i.e.:

\[
    T \rightarrow T_1,\dots,T_k \quad [C], \; where \; k \geq 1.
\]

\noindent
The main benefit of this semantics is regarding the \emph{method} decomposition Definition~\ref{def02:10}. By forbidding the usage of \emph{empty methods} we are not able to create fuzzy situations with unclear constraints. This way we do not need to adjust any definition and everything works as it should.

\medskip\noindent
As it happens in life, forbidding something might help in some cases but, on the other hand, it closes doors for the flexibility and advantages of \emph{empty methods}. Now, it is not possible to fulfill the task by doing nothing which might be very convenient in states that already hold all desired \emph{propositional symbols}. In such states, the decomposition of certain \emph{compound tasks} is meaningless and creates \emph{plans} that are longer and more redundant than \emph{plans} which would allow \emph{empty methods}.

\medskip\noindent
Succeeding models will allow different kinds of \emph{empty methods}, usually by handling some workaround.

\subsection{No-op Based Model (version 1)}

\medskip\noindent
Another possible way to resolve the issue with \emph{empty methods} is the No-op model~\cite{ondrckova2023semantics}. The no-op model introduces a new symbol $no\text{-}op()$ which is not presented in the \emph{hierarchical planning domain}. Formally, the $no\text{-}op()$ symbol is just another \emph{primitive task} with no preconditions and effects, i.e. $no\text{-}op() = \{\{\}, \{\}, \{\}\}$. The semantics behind this symbol is hidden right in the name, "no operation", meaning that this action has no impact on the world that we model. It serves as a regular symbol during the planning phase concerning all of the \emph{ordering constraints} and \emph{before-, after-, between-constraint}. After the checking of all available constraints, the $no\text{-}op()$ symbol is deleted from the final \emph{plan} as it was not part of the former \emph{planning problem}.

\medskip\noindent
Pros of the no-op model are easily seen. We have solved the issue of \emph{empty methods} by introducing a new symbol $no\text{-}op()$ and at the same time we did not need to allow regular \emph{empty methods} which decompose a task into an empty set. The no-op model extends the previous model Section~\ref{sub03:311}.

\medskip\noindent
Cons of this model appear in the HTN plan verification, reverse process to the \emph{hierarchical planning}. The main problem is due to the fact that the $no\text{-}op()$ symbols are not part of the input to the plan verification because they are removed after the check of all constraints in a \emph{primitive task network} (consists only of \emph{primitive tasks}). For this reason, the no-op model is inefficient for plan verification because it would be need to guess the locations and number of no-op() symbols in the input \emph{plan}, e.g.:

\begin{gather*}
    input: \pi = (task1, task2, task3) \\
    guess 1: (task1, task2, task3) \\
    guess 2: (task1, no\text{-}op(), task2, task3) \\
    guess 3: (no\text{-}op(), task1, task2, task3, no\text{-}op()) \\
    guess 4: (task1, no\text{-}op(), no\text{-}op(), no\text{-}op(), task2, task3)
\end{gather*}

\subsection{No-op Based Model (version 2)}

\medskip\noindent
The main problem with the no-op model is the inability to verify \emph{plan} efficiently. In the preceding no-op model, we erase $no\text{-}op()$ symbols after the checking of all constraints. It is possible to avoid this problem by forcing the planner of \emph{planning problem} to include the $no\text{-}op()$ symbol into his \emph{planning domain} and treat it as an \emph{empty method} (in some sense). With this practice, the planner will not need to erase $no\text{-}op()$ symbols in the resulting \emph{plan} which will make HTN plan verification much more efficient.

\subsection{Constraint Graph Model}

\subsection{Index Based Model}

\subsection{Increment Based Model}

\section{compound task with special semantics + CS that need to achieve some propos symbol + operators without negative effects}
