\chapter{Transformations of {HTN} {M}odels}

\medskip\noindent
After an exhaustive enumeration of various definitions and semantics, we will finally start discussing the transformation of different HTN models. This chapter will exhibit varying transformations along divergent contexts and preconditions. For example, HTN models might be partially-ordered, totally-ordered, with or without \emph{goal tasks}, having a different set of allowed \emph{state-constraints}. Moreover, we will look at differing formalisms and try to compile away unsupported features. Our scope of interest is transformations that do not change the set of \emph{solutions} to the \emph{planning problem}.

\section{Normal Forms}

\medskip\noindent
The first section of this chapter is inspired by the \emph{Chomsky normal form} (CNF)~\cite{chytil}. A context-free grammar (CFG) is in CNF if all of its production rules are of the form: $A \rightarrow BC$, $A \rightarrow a$, $S \rightarrow \varepsilon$ (in this case $S$ cannot be on the right side of a production rule) where $A, B, C$ are nonterminal symbols, $a$ is a terminal symbol, $S$ is a starting nonterminal symbol, and $\varepsilon$ denotes an empty symbol. This "nice" form of CF grammar allows us to prove important theorems about CF languages more easily. Similarly, we want to have "nice" forms of \emph{planning domains} without \emph{empty methods} which might speed up algorithms for planning, or plan verification. Also, these forms are useful for proving HTN theorems~\cite{langclassification}~\cite{cmyk}.

\begin{defn}\label{def04:14}
    A \emph{hierarchical planning problem} $\mathcal{P} = (s_0,\omega,\mathcal{D})$ is said to be in $\text{NF}_{\geq 2}$~\cite{langclassification} if all methods are of the form: $T \rightarrow T_1, \dots, T_k \; [C], k \geq 2$; $T \rightarrow a \; [C]$ where $T, T_1, \dots, T_k$ are \emph{compound tasks}, and $a$ is a \emph{primitive task (action)}.
\end{defn}

\begin{defn}\label{def04:15}
    A \emph{hierarchical planning problem} $\mathcal{P} = (s_0,\omega,\mathcal{D})$ is said to be in \emph{HTN-CNF} if all of its methods are of the form: $T \rightarrow T_1, T_2 \; [C]$; $T \rightarrow a \; [C]$ where $T, T_1, T_2$ are \emph{compound tasks}, and $a$ is a \emph{primitive task}. 
\end{defn}

\medskip\noindent
In Definitions~\ref{def04:14},~\ref{def04:15} we exclude the possibility of having empty \emph{plans} but this decision can be interchanged at any time. Moreover, these definitions do not allow \emph{empty methods}.

\begin{defn}\label{def04:16}
    We say that two \emph{planning problems} $\mathcal{P'}$, $\mathcal{P''}$ are equivalent if the set of solutions of $\mathcal{P'}$ is equal to the set of solutions of $\mathcal{P''}$.
\end{defn}

\begin{thm}\label{thm04:5}
    Every \emph{planning problem} $\mathcal{P}$ (partially-, totally-ordered) that does not generate an empty \emph{plan} as a \emph{solution}, without \emph{state-constraints} (before, after, between) can be transformed into \emph{an equivalent planning problem} in $\text{NF}_{\geq 2}$.
\end{thm}
\begin{proof}
    The proof follows the ideas of the transformation of CFG into CNF~\cite{chytil}. First of all, we need to get rid of \emph{empty methods}. For that, we need to find all \emph{nullable compound tasks}. \emph{A compound task} $T$ is \emph{nullable} if \emph{a method} $T \rightarrow \varepsilon \; [\{\}]$ exists, or if there is a sequence of \emph{decomposition} such that $T \rightarrow \dots \rightarrow \varepsilon \; [C]$. \emph{Nullable compound tasks} can be found followingly: for each \emph{method} $T \rightarrow \varepsilon \; [\{\}]$, $T$ is \emph{nullable}, and for each \emph{method} $T \rightarrow T_1, \dots, T_k \; [C], \; k \geq 1$ where $T_1, \dots, T_k$ are \emph{nullable}, $T$ is also \emph{nullable} (\emph{actions} are never \emph{nullable}). Having all \emph{nullable tasks}, we can remove \emph{empty methods} from the domain. After that, for each \emph{method} $T \rightarrow T_1, \dots, T_k \; [C]$ holding $i \geq 1$ \emph{nullable tasks} as subtasks, we create $2^i$ new methods with/without \emph{nullable tasks}, one special case is if $i = k$ then we do not create a new \emph{empty method} $T \rightarrow \varepsilon \; [C]$. All \emph{ordering-constraints} containing removed tasks are also removed in each new method. 
    
    The next step is to remove \emph{methods} of a form $T \rightarrow T_1 \; [\{\}]$ where $T, T_1$ are \emph{compound tasks}. These \emph{methods} will be called - \emph{unit methods}. For that, we need to find all \emph{unit pairs}. \emph{A unit pair} $(T_1, T_2)$ is a pair of \emph{compound tasks} such that $T_2$ can be decomposed from $T_1$ only with the usage of \emph{unit methods}, i.e., $T_1 \rightarrow \dots \rightarrow T_2 \; [C]$. After that, for each \emph{unit pair} $(T_1, T_2)$ and for each non-\emph{unit-method} $T_2 \rightarrow T_i, \dots, T_j \; [C_2], i < j$, we create a new method: $T_1 \rightarrow T_i, \dots, T_j \; [C_2], i < j$ (\emph{ordering-constraints} are inherited from the second \emph{method}). Doing so, we can delete all \emph{unit-methods} from the \emph{planning problem} without the modification of \emph{solutions}.

    For each \emph{action} $a$ we produce a new \emph{compound task} $T_a$, a new \emph{method} $T_a \rightarrow a \; [\{\}]$, and for each \emph{method} $T \rightarrow T_1, \dots, T_k \; [C]$ having $a$ as a $subtask$ we delete $a$ from the $subtasks$ and include $T_a$ instead. All \emph{ordering-constraints} having $a$ are interchanged with ones containing $T_a$. 

    In this proof, we deleted all \emph{empty methods}, \emph{unit methods}, and modified \emph{methods} so they have single \emph{action} or \emph{compound tasks} as $subtasks$. Thus, all \emph{methods} left have a form: $T \rightarrow T_1, \dots, T_k \; [C], k \geq 2$; $T \rightarrow a \; [\{\}]$ where $T, T_1, \dots, T_k$ are \emph{compound tasks}, and $a$ is \emph{action}. In every step, we did not create nor remove any potential \emph{solution}.

    %without ordering cycles, anebo pouze souvisle ordering casti a nezavisle ulohy volne
    %total order za sebou bez ocasku se da brat jako MACRO TASK, protoze to musi byt striktne za sebou
    %udelat graf orderingu
\end{proof}

\begin{defn}\label{def04:17}
    \emph{A method} $T \rightarrow T_1, \dots, T_k \; [C]$ has \emph{linear ordering-constraints} $C$ if $subtasks$ can be split into disjunctive sets (set partition) $S_1, \dots, S_k, k \geq 1$ such that all \emph{ordering-constraints} between tasks are within the same set, and all tasks within one set $S_i$ are linearly ordered (directly or transitively). Tasks not contained in any of \emph{ordering-constraints} are in sets of one element.
\end{defn}

\begin{thm}\label{thm04:6}
    Every \emph{planning problem} $\mathcal{P}$ in $\text{NF}_{\geq 2}$, with all \emph{methods} containing only \emph{linear ordering-constraints}, without \emph{state-constraints} (before, after, between) can be transformed into \emph{an equivalent planning problem} in \emph{HTN-CNF}.
\end{thm}
\begin{proof}
     In this proof, we will need to divide the large \emph{methods} into smaller ones. Because all tasks are linearly ordered within the divided sets we know that there cannot be "ordering cycles", also we know that at every time in every task set, there is the smallest task, with respect to \emph{ordering-constraints}. A key feature of such constraints is that the tasks in sets are mutually independent because, from the definition, between tasks from different sets no \emph{ordering-constraints} exist. 

     Let us have \emph{a method} $T \rightarrow T_1, \dots, T_k \; [C], k \geq 2$, and a set partition of tasks $S_1, \dots, S_k, k \geq 1$ by the Definition~\ref{def04:17}. Now, we will transform the input \emph{planning problem} $\mathcal{P}$ into the result \emph{HTN-CNF} \emph{planning problem} in two steps. First, we will add new \emph{compound tasks} $S_1, \dots, S_k$ (same names as set partitions) and $k - 2$ $C_i$ \emph{compound tasks} to the \emph{planning problem}. After that, we will add new \emph{methods}: $T \rightarrow S_1, C_1 \; [\{\}]; \; C_1 \rightarrow S_2, C_2 \; [\{\}]; \; C_{k - 2} \rightarrow S_{k - 1}, S_k \; [\{\}]$. Newly created methods have an empty set of constraints because, as was mentioned, tasks from different partitions do not have any ordering relations between them. Therefore, their subtasks can interleave without any restrictions. One special case that might occur is if the set of $subtasks$ is fully linearly ordered then there will be only one partition $S_1$. This situation can be handled by creating only one \emph{method} $T \rightarrow S_1, no\text{-}op() \; [\{\}]$ where $no\text{-}op()$ is a new \emph{action}, "fake empty method" introduced in the previous chapter.
\end{proof}%check ze nemame jen S_1, nebo ze nemame jen 2 CT a takoveto srandy

\medskip\noindent
\xxx{proc ty podminky musi byt takhle, ukazat obrazky grafu kdy a jak to jde a grafu kdy to nelze rozdelit, problem je v tom ze se PO podulohy muzou prolinat a nektere ordering grafy nejde binarizovat}

\begin{thm}\label{thm04:7}
    every TO -> without empty method
\end{thm}
\begin{proof}
    p
\end{proof}

\begin{thm}\label{thm04:8}
    every TO without between -> htn-cnf
\end{thm}
\begin{proof}
    p
\end{proof}

\section{State-Constraints Modification}

\section{many different formalisms and languages...look for features that can be transformed or deleted}
\cite{hddl}

\section{Next}